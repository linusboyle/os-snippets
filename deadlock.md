./vector-deadlock -n 2 -l 1 -v实际上没有启用死锁，或者更具体地说，两个线程都是按照向量1和2调用add的。

观察vector-deadlock的实现可以发现，add函数是按照先dst再src的固定顺序申请锁的。因此在这种情况下不会死锁。但是如果两个线程的参数不固定，比如一个是先1后2，一个是先2后1，那么就可能死锁。

运行程序发现，可能有两种输出，分别是：

```
->add(0, 1)
<-add(0, 1)
              ->add(0, 1)
              <-add(0, 1)
```

和
```
              ->add(0, 1)
              <-add(0, 1)
->add(0, 1)
<-add(0, 1)
```

这是因为先获得锁的一方不固定，但是也可以看出，一旦得到锁执行不会被打断
